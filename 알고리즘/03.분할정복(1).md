## 분할정복 방법
### 분할정복 방법의 원리
- 순환적으로 문제를 푸는 하향식 접근 방법
    + 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 그 해를 결합하여 원래 문제의 해를 구하는 방식
- 특징
    + 분할된 작은 문제는 원래 문제와 동일
        * 단, 입력 크기만 작아짐 
    + 분할된 문제는 서로 독립적
        * 순환적 분할 및 결과 결합이 가능
- 각 순환 호출 시의 처리 과정 
    + 분할
        * 주어진 문제를 여러 개의 작은 문제로 분할 
    + 정복
        * 작은 문제들을 순환적으로 분할. 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 출분히 작다면 순환 호출 없이 작은 문제에 대한 해를 구함
    + 결합
        * 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함
- 적용 알고리즘에서의 분할 과정
    + 이진 탐색
        * n개의 데이터가 입력되었을 때 1/2로 분할. 1/4로 분할...(한쪽은 사용하지 않는다)
    + 합병 정렬
        * 이진탐색과 마찬가지로 n개의 데이터가 입력되었을 때 1/2로 분할. 1/4로 분할...(양쪽을 모두 사용한다)
    + 퀵 정렬
        * 두개로 나누는데 일정하지 않은 다양한 크기로 두개씩 분할된다.(양쪽을 모두 사용한다.)
    + 선택 문제
        * 두개로 나누는데 일정하지 않는 다양한 크기로 두개씩 분할된다.(한쪽은 사용하지 않는다)

### 이진 탐색
- 정렬된 상태의 데이터에 대해 적용 가능한 효과적인 탐색 방법
    + 오름차순으로 정렬되었다고 가정
- 탐색 방법
    + 배열의 가운데 원소와 탐색키 x를 비교
        1. 탐색키 = 가운데 원소 -> 탐색 성공
        2. 탐색키 < 가운데 원소 -> 이진 탐색(크기 1/2의 왼쪽 부분배열) 순환 호출
        3. 탐색키 > 가운데 원소 -> 이진 탐색(크기 1/2의 오른쪽 부분배열) 순환 호출
    + 탐색을 반복할 때마다 대상 원소의 개수가 1/2씩 감소한다.
- 처리 과정
    + 분할
        * 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할. 탐색키와 가운데 원소가 같으면 해당 원소의 배열 인덱스를 반환/종료
    + 정복
        * 탐색키 x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출
    + 결합 
        * 부분배열에 대한 탐색 결과가 직접 반환되므로 결합 단계 불필요
- 입력 크기 n일 때 최대 분할 횟수는?
    + log n
    + 8개이면 3번 분할
- 입력 크기 n일때 최대 비교 횟수는?
    + n + 1
    + 8개이면 9번 비교
- 성능 분석
    + 입력 크기 n에 대한 탐색과정에서의 모든 비교 횟수의 합
    + 맨 바깥 수준에서의 비교횟수 + 순환 호출에서의 비교 횟수
    + T(n) = log n
- 특징
    + 입력이 정렬된 리스트에 대해서만 적용 가능
    + 삽입 삭제 연산시 데이터의 정렬 상태 유지가 필요 
        * 평균 n/2개의 데이터 이동이 발생 -> 삽입/삭제가 빈번한 응용에는 부적합

### 퀵 정렬
- 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
    + 오름차순으로 정렬한다고 가정
- 피벗
    + 두 부분배열로 분할할 때 기준이 되는 특정 원소
    + 보통 주어진 배열의 첫번째 요소로 지정
- 피벗이 제자리를 잡도록 하여 정렬하는 방식
- 왼쪽은 피벗보다 작고 오른쪽은 피벗보다 크다
- 처리과정
    + 분할: 피벗을 기준으로 주어진 배열을 두 부분배열로 분할
    + 정복: 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬
    + 결합: 필요없음
- 성능 분석
    + 피벗을 중심으로 균등하게 되어있는 경우와: 최선의 경우
    + 쏠려있는 경우: 최악의 경우
    + T(n) = O(nlog n)

### 합병 정렬
- 배열을 동일한 크기의 두개의 부분배열로 분할하고, 각각의 부분배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦
- 처리과정
    + 분할: 입력 크기 n인 배열을 크기 n/2인 두 부분배열로 분할
    + 정복: 각 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분배열을 정렬
    + 결합: 정렬된 두 부분배열을 합병하여 하나의 배열로 만듦
- 성능 분석
    + 크기 n/2인 두번의 순환호출 + 한 번의 합병

### 선택문제
- n개의 원소가 임의의 순서로 저장된 배열 A[0..n-1]에서 i번째로 작은 원소를 찾는 문제
- i=1 -> 최솟값 / i=n/2 -> 중간값 / i=n -> 최댓값
- 직관적인 방법
    + 오름차순으로 정렬한 후 i번째 원소를 찾는 방법
    + 최솟값 찾는 과정을 i번 방법
- 1) 퀵 정렬이용
    + 최악의 경우: 퀵 정렬의 최악인 경우 
        * 분할 함수가 항상 하나의 부분배열만 생성하는 경우
        * 오름차순으로 정렬된 상태에서 i=n을 찾는 경우-> 분할 함수 호출할 때마다 피벗의 인덱스는 1씩 증가 
        n^2이 된다.
- 2) 데이터를 다섯개로 나누어서 어쩌고

## 동적 프로그래밍 방법
- 문제의 크기가 작은 소문제에 대한 해를 저장해놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법
    + 각 작은 문제는 원래의 문제와 동일한 문제지만 입력의 크기만 작음
    + 입력의 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고, 이를 테이블에 저장
    + 이후 해당 소문제의 해가 필요할 때마다 테이블에 저장된 결과를 바로 이용
- 동적 프로그래밍이란 컴퓨터에서의 프로그램과는 무관, 해를 구축하는 테이블을 이용한다는 의미로 사용된다.(동적 계획법)
- 최솟값/최댓값을 구하는 최적화 문제에 주로 사용되는 설계기법
- 최적화 문제에 동적 프로그래밍 방법을 적용하려면?
    + 최적성의 원리: 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성된다.

### 분할정복 방법과 동적 프로그래밍 방법
- 하향식 / 상향식
- 독립적 / 독립적이지 않을 수 있다.
- 이진 탐색, 합병 정렬, 퀵 정렬, 선택문제 / 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집거리, 모든 정점간의 최단경로(플로이드 알고리즘), 저울 문제

### 피보나치 수열 문제

### 연쇄 행렬 곱셈 문제
- n개의 행렬(M1, M2, M3... Mn)을 연쇄적으로 곱하는 경우 최적의 곱셈 순서를 구하는 문제 = 최소의 기본 곱셈 횟수를 가진 행렬의 곱셈 순서를 구하는 문제

### 스트링 편집 거리 문제 
- 두 문자열 X와 Y사이의 편집거리
    + 두 문자열 사이의 근접성 또는 유사성을 판단하는 척도(스펠링 체크)
    + 문자열 X를 Y로 변환하는데 필요한 전체 편집 연산에 대한 최소비용
        * 특정 위치에 새 문자를 삽입하는 연산
        * 특정 위치의 문자를 삭제하는 연산
        * 특정 위치의 문자를 다른 문자로 변경하는 연산
- 성능: O(nm) X의 길이n과 Y의 길이 m의 곱으로 나타내어진다.
- 특징: E(i, j)로 선택되는 최솟값이 어떤 연산으로 결정되는지를 표시하면 적용된 편집 연산을 구할 수있다. 
### 모든 정점 간의 최단 경로
- 가중 방향 그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치의 합이 가장 작은 경로
- 가정: 가중치의 합이 음수인 사이클은 존재하지 않음
- 플로이드 알고리즘
    + 동적 프로그래밍 방법 적용
    + 간선의 인접 행렬 표현을 활용하여 경유할 수 있는 정점의 범위가 1인 경로부터 시작해서 |V|까지의 경로까지 단계적으로 범위를 늘려 가면서 모든 정점 간의 최단 경로를 구하는 알고리즘
- 성능: O(|V|^3) 정점의 개수의 3승
- 특징: 최단 경로 자체를 구할 수 있음
### 저울 문제
- 양팔 저울, n개의 추, 각 추의 무게 w
- 무게 M인 물체를 양팔 저울로 달 수 있는지 확인하는 문제
    + 모두 정수라는 가정
- 성능: O(nM) 추의 무게 n과 물체의 무게 M의 곱
- 특징
    + 무게 k의 증가를 추의 무게의 최대공약수 단위로 증가시키면 더 효율적이다.
    + 테이블s와 w를 이용하면 사용된 추를 구할 수 있다.
    + 물체의 무게가 2^n보다 크면 모든 경우를 따져 보는 직관적인 방법보다 비효율적

## 욕심쟁이 방법
- 해를 구하는 일련의 선택 단계마다 전후 단계의 선택과는 무관하게 해당 단계에서 가장 최선이라고 여겨지는 국부적인 최적해를 선택함으로써 전체적인 최적해를 구하는 방법 
- greedy
- 동적 프로그래밍 방법 / 욕심쟁이 방법
    + 최적화 문제 해결에 주로 사용
    + 최적성의 원리가 적용된 방법
    + 항상 전체적인 최적해를 구함 / 전체적인 최적해를 구하지 못할 수도 있음
- 욕심쟁이 방법의 한계 
    + 각각의 제일 좋은 방법을 찾는다고 해서 전체가 최적해가 아닐 수 있다.

### 동전 거스름돈 문제
- 고객에게 돌려줄 거스름돈이 있을 때 , 고객이 받을 동전의 개수를 최소로 하여 주는 방법
- 성능: O(n) 동전의 개수
- 특징
    + 동전의 액면가가 임의로 주어지는 일반적인 경우에는 욕심쟁이 방법으로 해결 불가

### 배낭 문제
- 최대 용량 M인 하나의 배낭과 n개의 물체
    + 각 물체 i에는 물체의 무게 w와 해당 물체를 배낭에 넣을 때 얻을 수 있는 이익 p
- 배낭의 용량을 초과하지 않는 범위 내에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 물체를 넣는 방법을 구하는 문제
- 가정: 물체를 쪼개서 넣을 수 있다는 가정
- 기본 아이디어: 물체의 무게는 적으면서도 이익이 가장 큰 물체부터 골라서 욕심을 내어 최대한 넣음
- 단위 무게당 이익이 가장 큰 물체부터 최대한 배낭에 넣는 과정을 반복
- 성능 O(nlogn)
- 특징
    + 0/1배낭 문제
        * 물체를 쪼갤 수 없는 형태의 배낭 문제는 욕심쟁이 방법 적용 불가하다.

### 최소 신장 트리
- 가중 무방향 그래프에서 모든 정점을 포함하는 연결된 트리
- 최소비용 신장 트리
    + 간선마다 가중치를 가진 연결된 무방향 그래프에 대해서 간선의 가중치의 합이 가장 작은 트리
- 종류
    + 크루스칼 알고리즘
        * 간선이 하나도 없는 상태에서 시작해서 가중치가 가장 작은 간선부터 하나씩 사이클을 만들지 않으면 추가시키는 방법
    + 프림 알고리즘
        * 임의의 한 정점에서 시작해서 연결된 정점을 하나씩 선택해서 나가는 방법

### 최단 경로
- 가중 방향 그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치의 합이 가장 작은 경로
- 데이크스트라 알고리즘
    + 단일 출발점 최단경로
    + O(V^2)
    + 음의 가중치를 갖는 간선이 없다고 가정
    + 출발점에서 시작하여 거리가 최소인 정점을 차례로 선택하여 최단 경로를 구하는 방법
    + 특징: 음의 가중치를 갖는 간선이 없어야 한다.

### 작업 스케쥴링 문제
- 가장 적은 개수의 기계를 사용해서 작업 간의 충돌이 발생하지 않도록 모든 작업을 기계에 할당하는 문제
- 기본 아이디어: 각 단계에서 시작 시간이 빠른 작업을 우선적으로 선택
- 성능 : O(nlogn)

### 작업 선택 문제
- 하나의 기계만을 사용해서 충돌 없이 최대 개수의 작업을 기계에 할당하는 문제
- 기본 아이디어: 각 단계에서 완료시간이 빠른 작업을 우선적으로 선택
- 성능 : O(nlogn)

### 허프만 코딩
- 문자의 빈도 똔느 확률 정보를 이용하는 통계적 압축 방법
    + 텍스트에서 각 문자가 출현하는 빈도수에 따라 다른 길이의 부호를 부여
- 성능: O(nlogn+m)
- 특징
    + 각 문자의 빈도수를 모르는 경우 주어진 텍스트를 두번 읽음 
    + 압축된 데이터를 디코딩하려면 압축률이 떨어진다.
